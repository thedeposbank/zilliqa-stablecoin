scilla_version 0
import BoolUtils IntUtils ListUtils

(* Based on file fungible-token.scilla from scilla repository *)

(***************************************************)
(*               Associated library                *)
(***************************************************)
library DPS_Token

let one = Uint128 1
let zero = Uint128 0
let t = True
let f = False

(* 30% *)
let devRate = Uint128 30000000

let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end

let le_int =
  fun (a : Uint128) => fun (b : Uint128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
    end

(* returns singleton List Message *)
let one_msg =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg


(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract DPS_Token
( init_owner : ByStr20,
  decimals : Uint32,
  name : String,
  symbol : String)

field owner : ByStr20 = init_owner
field pauser : ByStr20 = init_owner
field contractApprover : ByStr20 = init_owner
field fundraisingManager : ByStr20 = init_owner
field fundrContract : Option ByStr20 = None {ByStr20}
field devAcc : Option ByStr20 = None {ByStr20}
field devAccChanger : ByStr20 = init_owner
field fundrInProcess : Bool = False
field beforeFundrSupply : Uint128 = 0
field alreadyTransferredToDev : Uint128 = 0
field paused : Bool = False
field totalSupply : Uint128 = zero
field balances : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field allowed : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field approvedContracts : Map ByStr20 Bool = Emp ByStr20 Bool

transition BalanceOf(tokenOwner : ByStr20)
  bal <- balances[tokenOwner];
  match bal with
  | Some v =>
    msg = { _tag : "BalanceOfResponse"; _recipient : _sender; _amount : zero;
            address : tokenOwner; balance : v};
    msgs = one_msg msg;
    send msgs
  | None =>
    msg = { _tag : "BalanceOfResponse"; _recipient : _sender; _amount : zero;
            address : tokenOwner; balance : zero};
    msgs = one_msg msg;
    send msgs
  end
end

transition TotalSupply()
  ts <- totalSupply;
  msg = { _tag : "TotalSupplyResponse"; _recipient : _sender; _amount : zero;
          caller : _sender; totalSupply : ts };
  msgs = one_msg msg;
  send msgs
end

transition Transfer(to : ByStr20, tokens : Uint128, code : Uint32)
  isPaused <- paused;
  match isPaused with
  | False =>
    bal <- balances[_sender];
    match bal with
    | Some b =>
      can_do = le_int tokens b;
      match can_do with
      | True =>
        (* subtract tokens from _sender and add it to "to" *)
        new_sender_bal = builtin sub b tokens;
        balances[_sender] := new_sender_bal;

        (* Adds tokens to "to" address *)
        to_bal <- balances[to];
        new_to_bal = match to_bal with
        | Some x => builtin add x tokens
        | None => tokens
        end;

        balances[to] := new_to_bal;
        msg = { _tag : "TransferSuccess"; _recipient : to; _amount : zero;
                sender : _sender; amount : tokens; code : code};
        msgs = one_msg msg;
        send msgs
      | False =>
        (* balance not sufficient. *)
        msg = { _tag : "TransferFailure"; _recipient : _sender; _amount : zero;
                sender : _sender; amount : zero; code : code};
        msgs = one_msg msg;
        send msgs
      end
    | None =>
      (* no balance record, can't transfer *)
      msg = { _tag : "TransferFailure"; _recipient : _sender; _amount : zero;
              sender : _sender; amount : zero; code : code};
      msgs = one_msg msg;
      send msgs
    end
  | True =>
    e = { _exception : "Paused" };
    throw e
  end
end

transition TransferFrom(from : ByStr20, to : ByStr20, tokens : Uint128)
  isPaused <- paused;
  match isPaused with
  | False =>
    bal <- balances[from];
    (* Check if _sender has been authorized by "from" *)
    sender_allowed_from <- allowed[from][_sender];
    match bal with
    | Some a =>
      match sender_allowed_from with
      | Some b =>
        (* We can only transfer the minimum of available or authorized tokens *)
        t = min_int a b;
        can_do = le_int tokens t;
        match can_do with
        | True =>
          (* tokens is what we should subtract from "from" and add to "to" *)
          new_from_bal = builtin sub a tokens;
          balances[from] := new_from_bal;
          to_bal <- balances[to];
          match to_bal with
          | Some tb =>
            new_to_bal = builtin add tb tokens;
            balances[to] := new_to_bal
          | None =>
            (* "to" has no balance. So just set it to tokens *)
            balances[to] := tokens
          end;
          (* reduce "allowed" by "tokens" *)
          new_allowed = builtin sub b tokens;
          allowed[from][_sender] := new_allowed;
          msg = { _tag : "TransferFromSuccess"; _recipient : _sender; _amount : zero;
                  sender : from; recipient : to; amount : tokens };
          msgs = one_msg msg;
          send msgs
        | False =>
          msg = { _tag : "TransferFromFailure"; _recipient : _sender; _amount : zero;
                  sender : from; recipient : to; amount : zero };
          msgs = one_msg msg;
          send msgs
        end
      | None =>
        msg = { _tag : "TransferFromFailure"; _recipient : _sender; _amount : zero;
                sender : from; recipient : to; amount : zero };
        msgs = one_msg msg;
        send msgs
      end
    | None =>
      msg = { _tag : "TransferFromFailure"; _recipient : _sender; _amount : zero;
              sender : from; recipient : to; amount : zero };
      msgs = one_msg msg;
      send msgs
    end
  | True =>
    e = { _exception : "Paused" };
    throw e
  end
end

transition Approve(spender : ByStr20, tokens : Uint128)
  isPaused <- paused;
  match isPaused with
  | False =>
    allowed[_sender][spender] := tokens;
    msg = { _tag : "ApproveSuccess"; _recipient : _sender; _amount : zero;
            approver : _sender; spender : spender; amount : tokens };
    msgs = one_msg msg;
    send msgs
  | True =>
    e = { _exception : "Paused" };
    throw e
  end
end

transition Allowance(tokenOwner : ByStr20, spender : ByStr20)
  spender_allowance <- allowed[tokenOwner][spender];
  match spender_allowance with
  | Some n =>
      msg = { _tag : "AllowanceResponse"; _recipient : _sender; _amount : zero;
              owner : tokenOwner; spender : spender; amount : n };
      msgs = one_msg msg;
      send msgs
  | None =>
      msg = { _tag : "AllowanceResponse"; _recipient : _sender; _amount : zero;
              owner : tokenOwner; spender : spender; amount : zero };
      msgs = one_msg msg;
      send msgs
  end
end

transition transferOwnership(newOwner : ByStr20)
  ow <- owner;
  valid_auth = builtin eq _sender ow;
  match valid_auth with
  | True =>
    owner := newOwner
  | False => 
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

transition updatePauser(newPauser : ByStr20)
  ow <- owner;
  valid_auth = builtin eq _sender ow;
  match valid_auth with
  | True =>
    pauser := newPauser
  | False => 
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

transition updateFundraisingManager(newFundraisingManager : ByStr20)
  ow <- owner;
  valid_auth = builtin eq _sender ow;
  match valid_auth with
  | True =>
    fundraisingManager := newFundraisingManager
  | False => 
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

transition updateDevAccChanger(newDevAccChanger : ByStr20)
  ch <- devAccChanger;
  valid_auth = builtin eq _sender ch;
  match valid_auth with
  | True =>
    devAccChanger := newDevAccChanger
  | False => 
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

transition connectFundraisingContract(address : ByStr20)
  mgr <- fundraisingManager;
  valid_auth = builtin eq _sender mgr;
  match valid_auth with
  | True =>
    new_addr = Some {ByStr20} address;
    fundrContract := new_addr
  | False => 
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

transition updateContractApprover(newContractApprover : ByStr20)
  ow <- owner;
  valid_auth = builtin eq _sender ow;
  match valid_auth with
  | True =>
    contractApprover := newContractApprover
  | False => 
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

transition approveContract(address : ByStr20)
  apprvr <- contractApprover;
  valid_auth = builtin eq _sender apprvr;
  match valid_auth with
  | True =>
    approvedContracts[address] := t
  | False =>
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

transition revokeContract(address : ByStr20)
  apprvr <- contractApprover;
  valid_auth = builtin eq _sender apprvr;
  match valid_auth with
  | True =>
    delete approvedContracts[address]
  | False =>
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

procedure mint(to : ByStr20, value : Uint128)
  t <- totalSupply;
  newTotalSupply = builtin add value t;
  totalSupply := newTotalSupply;
  x <- balances[to];
  current_val = match x with
                | Some v => v
                | None   => zero
                end;
  new_bal = builtin add value current_val;
  balances[to] := new_bal;
end

transition transferToDev()

end

transition pause()
  psr <- pauser;
  valid_auth = builtin eq _sender psr;
  match valid_auth with
  | True =>
    paused := t
  | False => 
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

transition unpause()
  psr <- pauser;
  valid_auth = builtin eq _sender psr;
  match valid_auth with
  | True =>
    paused := f
  | False => 
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

transition mint(to : ByStr20, value : Uint128)
  valid_auth <- exists approvedContracts[_sender];
  match valid_auth with
  | True =>
    isPaused <- paused;
    match isPaused with
    | False =>
      t <- totalSupply;
      newTotalSupply = builtin add value t;
      totalSupply := newTotalSupply;
      x <- balances[to];
      current_val = match x with
                    | Some v => v
                    | None   => zero
                    end;
      new_bal = builtin add value current_val;
      balances[to] := new_bal;
      msg = { _tag : "MintSuccess"; _recipient : to; _amount : zero;
              sender : _sender; amount : value };
      msgs = one_msg msg;
      send msgs
    | True =>
      e = { _exception : "Paused" };
      throw e
    end
  | False =>
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

transition burn(from : ByStr20, value : Uint128)
  valid_auth <- exists approvedContracts[_sender];
  match valid_auth with
  | True =>
    isPaused <- paused;
    match isPaused with
    | False =>
      x <- balances[from];
      current_bal = match x with
                    | Some v => v
                    | None   => zero
                    end;
      enough = uint128_le value current_bal;
      match enough with
      | True =>
        t <- totalSupply;
        newTotalSupply = builtin sub t value;
        totalSupply := newTotalSupply;
        new_bal = builtin sub current_bal value;
        balances[from] := new_bal;
        msg = { _tag : "BurnSuccess"; _recipient : from; _amount : zero;
                sender : _sender; amount : value };
        msgs = one_msg msg;
        send msgs
      | False =>
        e = { _exception : "OverdrawnBalance" };
        throw e
      end
    | True =>
      e = { _exception : "Paused" };
      throw e
    end
  | False =>
    e = { _exception : "SenderNotAuthorized" };
    throw e
  end
end

